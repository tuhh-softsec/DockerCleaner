{"seed":4036939100,"processedDockerfileHash":"6b99211322574e292a4a31f4ae093001","fixedSmells":["use-no-install-recommends","do-not-use-apt-get-update-alone","pin-package-manager-versions-apt-get","pin-package-manager-versions-pip","pin-package-manager-versions-npm","pin-package-manager-versions-gem","pin-package-manager-versions-apk","use-copy-instead-of-add","use-wget-instead-of-add","do-not-have-secrets","have-a-healthcheck","have-a-user"],"successfullyFixedSmells":["use-no-install-recommends","have-a-healthcheck","have-a-user"],"processedDockerfile":"#  ######################################################################################\n#\n#   Dockerfile to start a pyGATB/Ptyhon compiling machine using these dependencies:\n#\n#       -->  gcc 4.9 \n#       -->  CMake 3.7.2\n#       -->  Python 3.4\n#       -->  Cython 0.25.2\n#\n#     See below to change these values.\n#\n#  --------------------------------------------------------------------------------------\n#\n#   Use:\n#\n#     For starters, you can look at the docker/build-debian.sh script which builds the\n#     the container and runs a pyGATB compilation with it.\n#\n#   ### To build the container, use: \n#\n#       docker build -f Dockerfile.debian_compiler -t pygatb/debian_compiler .\n#\n#   ### To run the container.\n#\n#     Running the container means that you want to compile pyGATB. For that\n#     purpose, docker run expects some information, as illustrated in this\n#     command:\n#\n#     docker run -it\n#       -v /path/to/py-gatb-source/pyGATB:/mnt/pyGATB    <-- source code\n#       -v /path/to/py-gatb-build/:/mnt/pyGATB-build     <-- compiled code\n#       -v /path/to/py-gatb-artifacts/:/mnt/artifacts    <-- where lay the egg\n#       pygatb/debian_compiler                           <-- container to start\n#       build                                            <-- script to run\n#       -DCMAKE_CXX_FLAGS_RELEASE=\"-march=native -Ofast\" <-- cmake arguments\n#\n#     First of all, we have retain that the code is not compiled within the\n#     container. Instead we use three external volumes bound to the container using\n#     two docker run \"-v\" arguments. These three volumes simply target:\n#\n#        1. a directory containing the pyGATB source code, i.e. a \"git clone\" of\n#           pyGATB repository;\n#        2. a directory containing the compiled code.\n#        3. a directory containing the egg file.\n#\n#     Using such a design, you can work with an existing clone of pyGATB\n#     repository and you can easily access the compiled code.\n#\n#     pyGATB compiled code directory (hereafter denoted as \"py-gatb-build\")\n#     must also exist on the host system. The container will erase its content\n#     content before running the code compiling procedure. (unless a file named\n#     keep-build is present in py-gatb-build. Thus, py-gatb-build\n#     is passed to docker run as follows:\n#\n#        -v /full/path/to/py-gatb-build/:/mnt/pyGATB-build\n#\n#        (do not modify \"/mnt/pyGATB-build\": this is the mount path within the\n#         container. For advanced use it can be altered with\n#         -e \"PYGATB_BUILD=/mnt/pyGATB-build )\n#\n#     The compilation can also be ran with a single mount point (easier):\n#\n#     docker run\n#       -v /path/to/py-gatb-source/:/mnt/    <-- parent directory to the source code\n#       pygatb/debian_compiler                           <-- container to start\n#       build                                            <-- script to run\n#       -DCMAKE_CXX_FLAGS_RELEASE=\"-march=native -Ofast\" <-- cmake arguments\n#\n#     The other directories (pyGATB-build and artifacts) are created in the directory\n#     to the source code.\n#\n#     Sample command from the real life (runs at the root of the repository):\n#     docker run --name debian_compiler -it -v \"$(realpath ..):/mnt\" pygatb/debian_compiler bash\n#\n#   ### Additional notes\n#   \n#     Root access inside the container:\n#\n#       - if running: docker exec -it debian_compiler bash\n#\n#       - if not yet running: docker run --rm -i -t pygatb/debian_compiler bash\n#\n#  ######################################################################################\n#   ###\n#       Base commands\n#\n#       We use a Debian 8 (Jessie) Linux\n#\nFROM debian:jessie\n#   who to blame?\nLABEL mainteners=\"Patrick Durand <patrick.durand@inria.fr>; Maël Kerbiriou <mael.kerbiriou@free.fr>\"\n#   ###\n#      Configuring gcc and cmake release\n#\nENV GCC_VERSION=\"4.9\" \\\n    CMAKE_SERIES=\"3.7\" \\\n    CMAKE_VERSION=\"3.7.2\" \\\n    PARALLEL_OPT=\"-j4\"\n#   ###\n#       Package installation and configuration\n#\n#       install latest packages of the base system\n#       as well as packages required to compile pyGATB\n#\nRUN echo \"APT::Install-Recommends \\\"false\\\";\\nAPT::Install-Suggests \\\"false\\\";\" >> /etc/apt/apt.conf \\\n && apt-get update \\\n && apt-get -y dist-upgrade \\\n && apt-get install --no-install-recommends wget make zlib1g-dev -y \\\n && apt-get clean\n#   ###\n#       Compiler installation\n#\n#       We need a c/c++ compiler in an appropriate release.\n#       Note: update-alternatives used by cmake installer (./boostrap)\n#             to locate gcc\n#\nRUN apt-get install --no-install-recommends gcc-${GCC_VERSION} g++-${GCC_VERSION} gcc-${GCC_VERSION}-base -y \\\n && update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-${GCC_VERSION} 100 \\\n && update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-${GCC_VERSION} 100 \\\n && apt-get clean\n#   ###\n#       CMAKE installation\n#\n#       we need cmake in aparticular release; we do not use: apt-get \n#       install cmake since we have to control which version we use.\n#       Cmake install procedure: https://cmake.org/install/\n#\nCOPY install-cmake.sh /tmp/\nRUN /tmp/install-cmake.sh $CMAKE_VERSION \\\n && rm /tmp/install-cmake.sh\n#   ###\n#       Python3 installation\n#\n#       Python, pip and Cython\n#\nRUN apt-get install --no-install-recommends python3 python3-dev python3-pip -y \\\n && apt-get clean \\\n && pip3 install pytest-runner pytest Cython==0.25.2 --install-option=\"--no-cython-compile\"\n#   ###\n#       Build scripts\n#\nCMD [\"build\"]\nCOPY build.sh /usr/local/bin/build\nRUN groupadd --system docker-user ; useradd --system --gid docker-user docker-user\nUSER docker-user\n# Please add your HEALTHCHECK here!!!\n","originalDockerfile":"# ######################################################################################\n#\n#  Dockerfile to start a pyGATB/Ptyhon compiling machine using these dependencies:\n#\n#      -->  gcc 4.9 \n#      -->  CMake 3.7.2\n#      -->  Python 3.4\n#      -->  Cython 0.25.2\n#\n#    See below to change these values.\n#\n# --------------------------------------------------------------------------------------\n#\n#  Use:\n#\n#    For starters, you can look at the docker/build-debian.sh script which builds the\n#    the container and runs a pyGATB compilation with it.\n#\n#  ### To build the container, use: \n#\n#      docker build -f Dockerfile.debian_compiler -t pygatb/debian_compiler .\n#\n#  ### To run the container.\n#\n#    Running the container means that you want to compile pyGATB. For that\n#    purpose, docker run expects some information, as illustrated in this\n#    command:\n#\n#    docker run -it\n#      -v /path/to/py-gatb-source/pyGATB:/mnt/pyGATB    <-- source code\n#      -v /path/to/py-gatb-build/:/mnt/pyGATB-build     <-- compiled code\n#      -v /path/to/py-gatb-artifacts/:/mnt/artifacts    <-- where lay the egg\n#      pygatb/debian_compiler                           <-- container to start\n#      build                                            <-- script to run\n#      -DCMAKE_CXX_FLAGS_RELEASE=\"-march=native -Ofast\" <-- cmake arguments\n#\n#    First of all, we have retain that the code is not compiled within the\n#    container. Instead we use three external volumes bound to the container using\n#    two docker run \"-v\" arguments. These three volumes simply target:\n#\n#       1. a directory containing the pyGATB source code, i.e. a \"git clone\" of\n#          pyGATB repository;\n#       2. a directory containing the compiled code.\n#       3. a directory containing the egg file.\n#\n#    Using such a design, you can work with an existing clone of pyGATB\n#    repository and you can easily access the compiled code.\n#\n#    pyGATB compiled code directory (hereafter denoted as \"py-gatb-build\")\n#    must also exist on the host system. The container will erase its content\n#    content before running the code compiling procedure. (unless a file named\n#    keep-build is present in py-gatb-build. Thus, py-gatb-build\n#    is passed to docker run as follows:\n#\n#       -v /full/path/to/py-gatb-build/:/mnt/pyGATB-build\n#\n#       (do not modify \"/mnt/pyGATB-build\": this is the mount path within the\n#        container. For advanced use it can be altered with\n#        -e \"PYGATB_BUILD=/mnt/pyGATB-build )\n#\n#    The compilation can also be ran with a single mount point (easier):\n#\n#    docker run\n#      -v /path/to/py-gatb-source/:/mnt/    <-- parent directory to the source code\n#      pygatb/debian_compiler                           <-- container to start\n#      build                                            <-- script to run\n#      -DCMAKE_CXX_FLAGS_RELEASE=\"-march=native -Ofast\" <-- cmake arguments\n#\n#    The other directories (pyGATB-build and artifacts) are created in the directory\n#    to the source code.\n#\n#    Sample command from the real life (runs at the root of the repository):\n#    docker run --name debian_compiler -it -v \"$(realpath ..):/mnt\" pygatb/debian_compiler bash\n#\n#  ### Additional notes\n#  \n#    Root access inside the container:\n#\n#      - if running: docker exec -it debian_compiler bash\n#\n#      - if not yet running: docker run --rm -i -t pygatb/debian_compiler bash\n#\n# ######################################################################################\n#  ###\n#      Base commands\n#\n#      We use a Debian 8 (Jessie) Linux\n#\nFROM debian:jessie\n#  who to blame?\nLABEL mainteners=\"Patrick Durand <patrick.durand@inria.fr>; Maël Kerbiriou <mael.kerbiriou@free.fr>\"\n#  ###\n#     Configuring gcc and cmake release\n#\nENV GCC_VERSION=\"4.9\" \\\n    CMAKE_SERIES=\"3.7\" \\\n    CMAKE_VERSION=\"3.7.2\" \\\n    PARALLEL_OPT=\"-j4\"\n#  ###\n#      Package installation and configuration\n#\n#      install latest packages of the base system\n#      as well as packages required to compile pyGATB\n#\nRUN echo \"APT::Install-Recommends \\\"false\\\";\\nAPT::Install-Suggests \\\"false\\\";\" >> /etc/apt/apt.conf \\\n && apt-get update \\\n && apt-get -y dist-upgrade \\\n && apt-get install wget make zlib1g-dev -y \\\n && apt-get clean\n#  ###\n#      Compiler installation\n#\n#      We need a c/c++ compiler in an appropriate release.\n#      Note: update-alternatives used by cmake installer (./boostrap)\n#            to locate gcc\n#\nRUN apt-get install --no-install-recommends gcc-${GCC_VERSION} g++-${GCC_VERSION} gcc-${GCC_VERSION}-base -y \\\n && update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-${GCC_VERSION} 100 \\\n && update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-${GCC_VERSION} 100 \\\n && apt-get clean\n#  ###\n#      CMAKE installation\n#\n#      we need cmake in aparticular release; we do not use: apt-get \n#      install cmake since we have to control which version we use.\n#      Cmake install procedure: https://cmake.org/install/\n#\nCOPY install-cmake.sh /tmp/\nRUN /tmp/install-cmake.sh $CMAKE_VERSION \\\n && rm /tmp/install-cmake.sh\n#  ###\n#      Python3 installation\n#\n#      Python, pip and Cython\n#\nRUN apt-get install python3 python3-dev python3-pip -y \\\n && apt-get clean \\\n && pip3 install pytest-runner pytest Cython==0.25.2 --install-option=\"--no-cython-compile\"\n#  ###\n#      Build scripts\n#\nCMD [\"build\"]\nCOPY build.sh /usr/local/bin/build\n","injectedSmells":[],"originalDockerfileHash":"ce467a4df68c9f32c2b47578f09ecd5c","successfullyInjectedSmells":[],"originalDockerfileUglified":"#  ######################################################################################\n#\n#   Dockerfile to start a pyGATB/Ptyhon compiling machine using these dependencies:\n#\n#       -->  gcc 4.9 \n#       -->  CMake 3.7.2\n#       -->  Python 3.4\n#       -->  Cython 0.25.2\n#\n#     See below to change these values.\n#\n#  --------------------------------------------------------------------------------------\n#\n#   Use:\n#\n#     For starters, you can look at the docker/build-debian.sh script which builds the\n#     the container and runs a pyGATB compilation with it.\n#\n#   ### To build the container, use: \n#\n#       docker build -f Dockerfile.debian_compiler -t pygatb/debian_compiler .\n#\n#   ### To run the container.\n#\n#     Running the container means that you want to compile pyGATB. For that\n#     purpose, docker run expects some information, as illustrated in this\n#     command:\n#\n#     docker run -it\n#       -v /path/to/py-gatb-source/pyGATB:/mnt/pyGATB    <-- source code\n#       -v /path/to/py-gatb-build/:/mnt/pyGATB-build     <-- compiled code\n#       -v /path/to/py-gatb-artifacts/:/mnt/artifacts    <-- where lay the egg\n#       pygatb/debian_compiler                           <-- container to start\n#       build                                            <-- script to run\n#       -DCMAKE_CXX_FLAGS_RELEASE=\"-march=native -Ofast\" <-- cmake arguments\n#\n#     First of all, we have retain that the code is not compiled within the\n#     container. Instead we use three external volumes bound to the container using\n#     two docker run \"-v\" arguments. These three volumes simply target:\n#\n#        1. a directory containing the pyGATB source code, i.e. a \"git clone\" of\n#           pyGATB repository;\n#        2. a directory containing the compiled code.\n#        3. a directory containing the egg file.\n#\n#     Using such a design, you can work with an existing clone of pyGATB\n#     repository and you can easily access the compiled code.\n#\n#     pyGATB compiled code directory (hereafter denoted as \"py-gatb-build\")\n#     must also exist on the host system. The container will erase its content\n#     content before running the code compiling procedure. (unless a file named\n#     keep-build is present in py-gatb-build. Thus, py-gatb-build\n#     is passed to docker run as follows:\n#\n#        -v /full/path/to/py-gatb-build/:/mnt/pyGATB-build\n#\n#        (do not modify \"/mnt/pyGATB-build\": this is the mount path within the\n#         container. For advanced use it can be altered with\n#         -e \"PYGATB_BUILD=/mnt/pyGATB-build )\n#\n#     The compilation can also be ran with a single mount point (easier):\n#\n#     docker run\n#       -v /path/to/py-gatb-source/:/mnt/    <-- parent directory to the source code\n#       pygatb/debian_compiler                           <-- container to start\n#       build                                            <-- script to run\n#       -DCMAKE_CXX_FLAGS_RELEASE=\"-march=native -Ofast\" <-- cmake arguments\n#\n#     The other directories (pyGATB-build and artifacts) are created in the directory\n#     to the source code.\n#\n#     Sample command from the real life (runs at the root of the repository):\n#     docker run --name debian_compiler -it -v \"$(realpath ..):/mnt\" pygatb/debian_compiler bash\n#\n#   ### Additional notes\n#   \n#     Root access inside the container:\n#\n#       - if running: docker exec -it debian_compiler bash\n#\n#       - if not yet running: docker run --rm -i -t pygatb/debian_compiler bash\n#\n#  ######################################################################################\n#   ###\n#       Base commands\n#\n#       We use a Debian 8 (Jessie) Linux\n#\nFROM debian:jessie\n#   who to blame?\nLABEL mainteners=\"Patrick Durand <patrick.durand@inria.fr>; Maël Kerbiriou <mael.kerbiriou@free.fr>\"\n#   ###\n#      Configuring gcc and cmake release\n#\nENV GCC_VERSION=\"4.9\" \\\n    CMAKE_SERIES=\"3.7\" \\\n    CMAKE_VERSION=\"3.7.2\" \\\n    PARALLEL_OPT=\"-j4\"\n#   ###\n#       Package installation and configuration\n#\n#       install latest packages of the base system\n#       as well as packages required to compile pyGATB\n#\nRUN echo \"APT::Install-Recommends \\\"false\\\";\\nAPT::Install-Suggests \\\"false\\\";\" >> /etc/apt/apt.conf \\\n && apt-get update \\\n && apt-get -y dist-upgrade \\\n && apt-get install wget make zlib1g-dev -y \\\n && apt-get clean\n#   ###\n#       Compiler installation\n#\n#       We need a c/c++ compiler in an appropriate release.\n#       Note: update-alternatives used by cmake installer (./boostrap)\n#             to locate gcc\n#\nRUN apt-get install --no-install-recommends gcc-${GCC_VERSION} g++-${GCC_VERSION} gcc-${GCC_VERSION}-base -y \\\n && update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-${GCC_VERSION} 100 \\\n && update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-${GCC_VERSION} 100 \\\n && apt-get clean\n#   ###\n#       CMAKE installation\n#\n#       we need cmake in aparticular release; we do not use: apt-get \n#       install cmake since we have to control which version we use.\n#       Cmake install procedure: https://cmake.org/install/\n#\nCOPY install-cmake.sh /tmp/\nRUN /tmp/install-cmake.sh $CMAKE_VERSION \\\n && rm /tmp/install-cmake.sh\n#   ###\n#       Python3 installation\n#\n#       Python, pip and Cython\n#\nRUN apt-get install python3 python3-dev python3-pip -y \\\n && apt-get clean \\\n && pip3 install pytest-runner pytest Cython==0.25.2 --install-option=\"--no-cython-compile\"\n#   ###\n#       Build scripts\n#\nCMD [\"build\"]\nCOPY build.sh /usr/local/bin/build\n","originalDockerfileUglifiedHash":"6c91f71c3104be9e6537747ee6e4fc32","fileName":"/ICSME-replicationpackage/dataset/smelly_dockerfiles_bianncle/a47eb6c3c6816ee2d622f0ad163e853756e02bb4.dockerfile"}